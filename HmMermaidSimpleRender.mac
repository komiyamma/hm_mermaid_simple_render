/*
 * HmMermaidSimpleRender 1.1.0.0
 * CC0 1.0 Universal
 */

jsmode "WebView2\\" + currentmacrofilename;

js {

const renderPaneName = "HmMermaidSimpleRender";


// 前回マクロを実行した際の、tickがまだ継続しているなら、クリアする。
if (typeof(intervalHandle) != "undefined") {
    hidemaru.clearInterval(intervalHandle);
}


var intervalHandle; // 宣言だけ。js{ }から脱出しても変数を次回マクロ実行時にも残すため、var にする。


// HTMLのテンプレート。
// このテンプレートの中の${text}の部分に、
// 秀丸の編集エリアのテキストを当てはめるためのもの
function getCurrentTotalHtml(text) {

    const htmlTemplate = 
`<html>
<head>
<title>HmMermaidSimpleRender</title>
<script type='module'>
import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'loose'});
</script>
<style>
.mermaid { display: none; }
</style>
</head>
<body>
<div class='mermaid'>
${text}
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
    let mermaidDiv = document.querySelector('.mermaid');
    mermaidDiv.style.display = 'block';
});
</script>
</body>
</html>
`;

    return htmlTemplate;
}

// 対象のテキスト内容をutf8で保存
function saveHtmlFile(fullPath, htmlText) {
    const saveSuccess = hidemaru.saveTextFile(fullPath, htmlText, "utf8");
}

// この関数で true が返ってくる時は、危険性があるので、javascriptのTickで処理をしない。
function isNotDetectedOperation() {

    /*
    ○ 0x00000002 ウィンドウ移動/サイズ変更中
    × 0x00000004 メニュー操作中
    × 0x00000008 システムメニュー操作中
    × 0x00000010 ポップアップメニュー操作中
    ○ 0x00000100 IME入力中
    × 0x00000200 何らかのダイアログ表示中
    × 0x00000400 ウィンドウがDisable状態
    × 0x00000800 非アクティブなタブまたは非表示のウィンドウ
    × 0x00001000 検索ダイアログの疑似モードレス状態
    ○ 0x00002000 なめらかスクロール中
    ○ 0x00004000 中ボタンによるオートスクロール中
    ○ 0x00008000 キーやマウスの操作直後
    ○ 0x00010000 何かマウスのボタンを押している
    × 0x00020000 マウスキャプチャ状態(ドラッグ状態)
    ○ 0x00040000 Hidemaru_CheckQueueStatus相当
    */
    const s = hidemaru.getInputStates();
    const notAllowedMask = 
          0x00000004 | 0x00000008 | 0x00000010 | 
          0x00000200 | 0x00000400 | 0x00000800 | 
          0x00001000 | 0x00020000;

    return (s & notAllowedMask) != 0;
}

// 前回のチェックと比べてファイルの最終更新日時は変化したのか？
let fso = null;
let lastFileModified = 0;
function getFileLastModifyUpdated() {
    if (!fso) { fso = hidemaru.createObject("Scripting.FileSystemObject"); }

    let isDiff = false;
    const filepath = hidemaru.getFileFullPath();
    if (filepath) {
        try {
            const fileobj = fso.GetFile(filepath);
            const modify = fileobj.DateLastModified;
            if (modify != lastFileModified) {
                lastFileModified = modify;
                isDiff = true;
            }
        }
        catch (e) {
        }
    }
    return isDiff;
}

// メッセージをアウトプット枠へと出力
function writeLineOutputPane(msg) {
    let dll = loaddll("HmOutputPane.dll");
    dll.dllFuncW.OutputW(hidemaru.getCurrentWindowHandle(), msg + "\r\n");
}

// 現在秀丸で編集しているテキストを、テンプレートを利用して、TEMPフォルダに保存
function saveCurrentTextToTempHtmlFile(curTotalText, tempHtmlFullPath) {

    // テンプレートに現在の編集エリアのテキスト内容を当てはめたものを取得
    const htmlText = getCurrentTotalHtml(curTotalText);

    // それをTEMPフォルダに保存
    saveHtmlFile(tempHtmlFullPath, htmlText);
}


// メインの処理
function main() {

    // TEMPフォルダに、
    const tempFolder = getenv("temp");
    const tempHtmlFullPath = `${tempFolder}\\${basename2()}.html`;

    // 現在の秀丸のテキスト内容をもとにHTMLテンプレートを当てはめて、TEMPフォルダにファイルを保存
    saveCurrentTextToTempHtmlFile(gettotaltext(), tempHtmlFullPath);

    // 取り出しやすいように、
    writeLineOutputPane(`${tempHtmlFullPath}:0 `);

    // 開始時点を最終更新時とする。
    getFileLastModifyUpdated();

    // 指定のパラメータでレンダーペインを開く。browserpanecommand にして、targetを "_each" にしてもほぼ同じこと
    renderpanecommand ( 
    {
        target: renderPaneName,
        url : tempHtmlFullPath,
        watch: 0,
        watchsave: 0,
        initialize: "async",
        show: 1,
        size : 800
    }
    );

    const intervalTickTime = 1000; // hidemaru.setIntervalの間隔。この間隔は担保されないので注意。
                                   // (実行の予約は概ね正確にこの間隔となるが、関数の実行は全く違う)

    let lastUpdateCount = 0; // 

    let lastTickCount = tickcount(); // Windowsが起動されてからの経過時間

    // 指定の間隔で
    intervalHandle = hidemaru.setInterval(() => {

        // ----------------------------------------------------------------
        // ヤバそうな操作の最中はパス
        if (isNotDetectedOperation()) {
            return;
        }

        // ----------------------------------------------------------------
        // 何も更新してないっぽいならパス。CPU負担を軽くするためのもの。
        const currentUpdateCount = updatecount();
        if (lastUpdateCount == currentUpdateCount) {
            return;
        }

        // 最後にチェックしたupdatecountを保存しておく。
        lastUpdateCount = currentUpdateCount;

        // ----------------------------------------------------------------
        // 本当にタイム差分が経過していることをチェックする。
        const currentTickCount = tickcount();

        // 経過した時間をもとめる。
        const elapsedTickTime = currentTickCount - lastTickCount;

        // それが指定のものよりも遥かに小さい(半分すらない)なら、早いタイミングでTickが来すぎているので、一旦スキップ
        if (elapsedTickTime < (intervalTickTime * 0.5)) {
            return;
        }

        lastTickCount = tickCount;

        // ----------------------------------------------------------------
        // 現在編集中のファイルの最終書き込のタイムスタンプが変化しか？
        const isFileLastModifyUpdated = getFileLastModifyUpdated();
        if (isFileLastModifyUpdated) {

            // 現在の秀丸のテキスト内容をもとにHTMLテンプレートを当てはめて、TEMPフォルダにファイルを保存
            saveCurrentTextToTempHtmlFile(gettotaltext(), tempHtmlFullPath);

            // レンダリングペインをリロードする。
            renderpanecommand ( {
                target: renderPaneName,
                url: "javascript: location.reload()"
            }
            );
        }

    }, intervalTickTime);
}

main();

}